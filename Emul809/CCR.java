import java.beans.PropertyChangeListener;

import javax.swing.event.SwingPropertyChangeSupport;

/**
 * This class details the condition code register (CCR) </br>
 * The CCR defines the
 * state of the processor flags at any given time
 * 
 * @author Robert Wilson
 * 
 */
public class CCR {

	/** Instance variables */
	public static final String BOUND_C = "bound C", BOUND_E = "bound E",
			BOUND_F = "bound F", BOUND_H = "bound h", BOUND_I = "bound I",
			BOUND_N = "bound N", BOUND_V = "bound V", BOUND_Z = "bound Z";
	private String bound_C = "0", bound_H = "0", bound_E = "0", bound_I = "0",
			bound_F = "0", bound_N = "0", bound_V = "0", bound_Z = "0";
	private SwingPropertyChangeSupport spcSupport = new SwingPropertyChangeSupport(
			this);

	public SwingPropertyChangeSupport getSpcSupport() {
		return spcSupport;
	}

	public void setSpcSupport(SwingPropertyChangeSupport spcSupport) {
		this.spcSupport = spcSupport;
	}

	/**
	 * Bit 0 (C) is the Carry Flag, usually generated by the binary carry from
	 * the MSB of the operation (ADC, ADD) -- this is an unsigned overflow
	 * 
	 * C is also used to represent a 'borrow' (a NOT-carry) to and from
	 * subtract-like instructions (CMP, NEG, SBC, SUB), and MUL uses C to
	 * represent b7 of the result for round-off purposes
	 * 
	 * Data movement and logical operations do not affect C, while arithmetic
	 * operations set C, if appropriate
	 */
	public String getBound_C() {
		return bound_C;
	}

	/**
	 * Method to implement changes to C register for display
	 * 
	 * @param bound_C - the String representing the C bit
	 */
	public void setBound_C(String bound_C) {
		String oldValue = this.bound_C;
		String newValue = bound_C;
		this.bound_C = newValue;
		spcSupport.firePropertyChange(BOUND_C, oldValue, newValue);
	}

	public void addPropertyChangeListener(PropertyChangeListener listener) {
		spcSupport.addPropertyChangeListener(listener);
	}

	/**
	 * Bit 1 (V) is the Overflow Flag, set when an operation causes a
	 * two's-complement arithmetic overflow, which is detected if the carry from
	 * the MSB in the binary ALU does not match the carry from the MSB-1
	 * 
	 * Loads, stores and logical operations clear V, while arithmetic operations
	 * set V if appropriate
	 */
	public String getBound_V() {
		return bound_V;
	}

	/**
	 * Method to implement changes to V register for display
	 * 
	 * @param bound_V - the Z bit
	 */
	public void setBound_V(String bound_V) {
		String oldValue = this.bound_V;
		String newValue = bound_V;
		this.bound_V = newValue;
		spcSupport.firePropertyChange(BOUND_V, oldValue, newValue);
	}

	/**
	 * Bit 2 (Z) is the Zero Flag, set if the result of the previous operation
	 * was identically zero
	 * 
	 * Loads, stores, logical and arithmetic operations set Z if appropriate
	 */
	public String getBound_Z() {
		return bound_Z;
	}

	/**
	 * Method to implement changes to z register for display
	 * 
	 * @param bound_Z - the Z bit
	 */
	public void setBound_Z(String bound_Z) {
		String oldValue = this.bound_Z;
		String newValue = bound_Z;
		this.bound_Z = newValue;
		spcSupport.firePropertyChange(BOUND_Z, oldValue, newValue);
	}

	/**
	 * Bit 3 (N) is the negative flag containing the value of the MSB of the
	 * result of the preceding operation, thus a negative two's complement
	 * result will set N
	 * 
	 * Loads, stores, logical and arithmetic operations all set N if appropriate
	 * 
	 * If two's complement overflow occurs the sign of the result (& the N flag)
	 * will be incorrect, thus two's complement branches use the expression (N
	 * XOR V) to obtain an always valid sign result
	 */
	public String getBound_N() {
		return bound_N;
	}

	public void setBound_N(String bound_N) {
		String oldValue = this.bound_N;
		String newValue = bound_N;
		this.bound_N = newValue;
		spcSupport.firePropertyChange(BOUND_N, oldValue, newValue);
	}

	/**
	 * Bit 4 (I) is the IRQ mask bit
	 * 
	 * If I is set the processor will not recognise interrupts from the IRQ line
	 * 
	 * NMI, FIRQ, IRQ, RESET and SWI all set I, while SW12 and SW13 do not
	 */
	public String getBound_I() {
		return bound_I;
	}

	public void setBound_I(String bound_I) {
		String oldValue = this.bound_I;
		String newValue = bound_I;
		this.bound_I = newValue;
		spcSupport.firePropertyChange(BOUND_I, oldValue, newValue);
	}

	/**
	 * Bit 5 (H) is the half-carry bit and is used to indicate a carry from b3
	 * in the ALU as a result of an 8-bit addition only (ADC or ADD)
	 * 
	 * H is used by the DAA instruction to perform a (BCD) decimal add adjust
	 * operation
	 * 
	 * The state of the H flag is undefined in all subtract-like instructions to
	 * allow for future expansion; software must not depend upon a particular
	 * state of the H flag after subtract operations
	 */
	public String getBound_H() {
		return bound_H;
	}

	public void setBound_H(String bound_H) {
		String oldValue = this.bound_H;
		String newValue = bound_H;
		this.bound_H = newValue;
		spcSupport.firePropertyChange(BOUND_H, oldValue, newValue);
	}

	/**
	 * Bit 6 (F) is the FIRQ mask bit
	 * 
	 * If F is set the processor will not recognise interrupts from the FIRQ
	 * line
	 * 
	 * NMI, FIRQ, RESET and SWI all set F, while SW12, SW13 and IRQ do not
	 */
	public String getBound_F() {
		return bound_F;
	}

	public void setBound_F(String bound_F) {
		String oldValue = this.bound_F;
		String newValue = bound_F;
		this.bound_F = newValue;
		spcSupport.firePropertyChange(BOUND_F, oldValue, newValue);
	}

	/**
	 * Bit 7 (E) is the entire flag and indicates either the complete machine
	 * state (all the registers) or the subset state (PC and CC) is being
	 * stacked. E is used by the RTI instruction to determine the extent of the
	 * un-stacking, thus allowing some interrupt handling routines which work
	 * with both fast and slow interrupts
	 * 
	 * FIRQ will clear E while IRQ, NMI, SWI, SWI2 and SWI3 will set E before
	 * stacking
	 * 
	 * The E bit associated with the saved registers is in the E flag position
	 * in the CC of the stacked state; the E bit in the processor has little
	 * meaning
	 */
	public String getBound_E() {
		return bound_E;
	}

	public void setBound_E(String bound_E) {
		String oldValue = this.bound_E;
		String newValue = bound_E;
		this.bound_E = newValue;
		spcSupport.firePropertyChange(BOUND_E, oldValue, newValue);
	}

}
